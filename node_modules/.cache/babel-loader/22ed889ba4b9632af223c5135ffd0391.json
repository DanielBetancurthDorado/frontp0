{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useEffect, useState, useRef, useCallback } from \"react\";\n\nconst useStateWithPromise = initialState => {\n  _s();\n\n  const [state, setState] = useState(initialState);\n  const resolverRef = useRef(null);\n  useEffect(() => {\n    if (resolverRef.current) {\n      resolverRef.current(state);\n      resolverRef.current = null;\n    }\n    /**\n     * Since a state update could be triggered with the exact same state again,\n     * it's not enough to specify state as the only dependency of this useEffect.\n     * That's why resolverRef.current is also a dependency, because it will guarantee,\n     * that handleSetState was called in previous render\n     */\n\n  }, [resolverRef.current, state]);\n  const handleSetState = useCallback(stateAction => {\n    setState(stateAction);\n    return new Promise(resolve => {\n      resolverRef.current = resolve;\n    });\n  }, [setState]);\n  return [state, handleSetState];\n};\n\n_s(useStateWithPromise, \"EUMSdK+jLdICJIaWW9bEXx6tPAg=\");\n\nexport default useStateWithPromise;","map":{"version":3,"sources":["/Users/danielbetancurth/Desktop/proyecto0cloud/src/hooks/statePromise.js"],"names":["React","useEffect","useState","useRef","useCallback","useStateWithPromise","initialState","state","setState","resolverRef","current","handleSetState","stateAction","Promise","resolve"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,EAA2BC,QAA3B,EAAoCC,MAApC,EAA4CC,WAA5C,QAA8D,OAA9D;;AAEA,MAAMC,mBAAmB,GAAIC,YAAD,IAAkB;AAAA;;AAC1C,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBN,QAAQ,CAACI,YAAD,CAAlC;AACA,QAAMG,WAAW,GAAGN,MAAM,CAAC,IAAD,CAA1B;AAEAF,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIQ,WAAW,CAACC,OAAhB,EAAyB;AACvBD,MAAAA,WAAW,CAACC,OAAZ,CAAoBH,KAApB;AACAE,MAAAA,WAAW,CAACC,OAAZ,GAAsB,IAAtB;AACD;AACD;AACN;AACA;AACA;AACA;AACA;;AACK,GAXQ,EAWN,CAACD,WAAW,CAACC,OAAb,EAAsBH,KAAtB,CAXM,CAAT;AAaA,QAAMI,cAAc,GAAGP,WAAW,CAAEQ,WAAD,IAAiB;AAClDJ,IAAAA,QAAQ,CAACI,WAAD,CAAR;AACA,WAAO,IAAIC,OAAJ,CAAYC,OAAO,IAAI;AAC5BL,MAAAA,WAAW,CAACC,OAAZ,GAAsBI,OAAtB;AACD,KAFM,CAAP;AAGD,GALiC,EAK/B,CAACN,QAAD,CAL+B,CAAlC;AAOA,SAAO,CAACD,KAAD,EAAQI,cAAR,CAAP;AACD,CAzBH;;GAAMN,mB;;AA0BJ,eAAeA,mBAAf","sourcesContent":["import React, { useEffect, useState,useRef ,useCallback} from \"react\";\n\nconst useStateWithPromise = (initialState) => {\n    const [state, setState] = useState(initialState);\n    const resolverRef = useRef(null);\n  \n    useEffect(() => {\n      if (resolverRef.current) {\n        resolverRef.current(state);\n        resolverRef.current = null;\n      }\n      /**\n       * Since a state update could be triggered with the exact same state again,\n       * it's not enough to specify state as the only dependency of this useEffect.\n       * That's why resolverRef.current is also a dependency, because it will guarantee,\n       * that handleSetState was called in previous render\n       */\n    }, [resolverRef.current, state]);\n  \n    const handleSetState = useCallback((stateAction) => {\n      setState(stateAction);\n      return new Promise(resolve => {\n        resolverRef.current = resolve;\n      });\n    }, [setState])\n  \n    return [state, handleSetState];\n  };\n  export default useStateWithPromise;"]},"metadata":{},"sourceType":"module"}